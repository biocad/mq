## Разработка компонента на новом языке

### Введение

На текущий момент компоненты реализованы на следующих языках: [haskell](https://github.com/biocad/mq-component-hs), [python](https://github.com/biocad/mq-component-py).

Вполне может случиться так, что среди этих языков нет того, на котором вы привыкли проводить разработку.
Поэтому возникнет необходимость в разработке компонента на вашем языке программирования.

Правильнее будет назвать его "компонентом-обёрткой", так как он предоставляет весь функционал для работы с системой MoniQue для всех последующих разрабатываемых компонентов, реализующих какую-то определённую логику.

Ниже перечислены шаги, по которым нужно будет пройти для достижения успеха.

### Имя и расположение разрабатываемого компонента

Разработчики MoniQue убедительно просят его разрабатывать в репозитории компании [BIOCAD](https://github.com/biocad).
За правами обратитесь к разработчикам MoniQue.

Для единообразия название "компонента-обёртки" должно быть сформировано по следующему шаблону: `mq-component-xxx`, где вместо `xxx` стоит самое частое расширение в используемом языке (к примеру, для Haskell - это `hs`, для Python - `py`).

### План разработки

Всю необходимую документацию можно найти в одноимённых разделах.

Ниже мы опишем тот план, которого мы советуем придерживаться при разработке компонента на новом языке программирования:
  * Протокол
    * Сообщение (типы и вспомогательные функции)
    * Тэги (создание, обращение к полям, фильтрация)
    * Кодировка (например, в/из JSON или MessagePack)
    * Ошибки
    * Сообщения технического уровня
  * Транспортный уровень
    * Отправка и получение сообщений по ZeroMQ
    * Подписки на сообщения в ZeroMQ
    * Автоматическое конвертирование в/из ByteString при отправке/получении
  * Межпоточное общение между техническим и коммуникационным слоями
  * Технический слой
    * Логика мониторинга
    * Логика "убийства" задач
  * Коммуникационный слой
    * Стандартные функции отправки/получения сообщений (с учётом логики технического слоя)
  * Конфигурации
    * Формат файла config.json
    * Чтение аргументов программы
  * Запуск приложения
  
Отдельно хотелось бы остановиться на пункте "Подписки на сообщения в ZeroMQ". Сначала несколько мыслей:
  * любое сообщение по [протоколу](Protocol.md) состоит из друх частей: тэг и тело сообщения;
  * компоненты слушают "одно место" в помощью паттерна ["Один ко всем"](Transport.md);
  * если компонент будет слушать все сообщения из "одного места" (даже если дальше он их будет отфильтровывать) и сообщений будет много, то он будет критически медленно работать;
  * в ZeroMQ для паттерна "один ко всем" есть возможность [оформить подписку](http://zguide.zeromq.org/page:all#Pub-Sub-Message-Envelopes) только на те сообщения, которые вам нужны.

Соединяя эти мысли воедино, получаем, что при разработке компонента стоит реализовать функцию подписки на соответствующие тэги с помощью тех средств, которые заложены в ZeroMQ.
Подписка на все сообщения (что тоже может быть полезно, например, для логирования) оформляется подпиской на пустую строку.
Так как тэг сообщения начинается с типа и спецификации, то подписка на соответствующие сообщения оформляются как подписка на `<тип>:<спецификания>`.
> Пример: при запросе другого компонента (RPC) стоит подписаться на получение результата или ошибки от него, а после получения ответа - отписаться.
> К примеру, если вы запрашиваете компонент со спецификацией `ss_ig-annotate`, то при ожидании ответа от него стоит подписаться на `result:ss_ig-annotate` и на `error:ss_ig-annotate`.
  
Дополнительно можно реализовать следующие пункты, которые могут очень сильно ускорить процесс разработки различных сервисов:
  * Формирование компонентов ошибки
  * Вызов "удалённого" компонента (отправить сообщение и дождаться интересующего ответа)
  * Набор шаблонов для поведения
    * "Слушатель" (умеет принимать и обрабатывать определённые сообщения)
    * "Рабочий" (умеет принимать сообщения, обрабатывать его и отправлять ответ обратно в систему)
    
Конечно, приведённые выше пункты являются только рекоммендацией и могут варьироваться в зависимости от языка разработки.

### План тестирования

После того, как разработанный модуль компонента реализован, можно приступить к его тестированию.
Для этого потребуется локально запущенное "одно место", запуск которого описан в "MoniQue за 5 минут".

Чтобы проверить правильность написания компонента, можно в соответствующей папке реализовать примеры, которые будут аналогичны примерам из уже существующих примеров на других языках программирования.
Тут важно подметить, что логика у компонентов на различных языках программирования в одинаковых примерах должна быть одинаковая.
И сообщения, с которыми они работают, также должны быть одинаковыми.

Это допущение позволит сделать следующее: запустить компоненты, которые должны общаться между собой (см. пример "Радио" [тут](https://github.com/biocad/mq-component-hs) или [тут](https://github.com/biocad/mq-component-py)), на различных языках программирования.
При этом один из компонентов будет уже из существующей (референсной) реализации, а другой - разрабатываемый.
Например, `example_radio-speaker-py` и `example_radio-listener-xy`.
Если компоненты на различных языках друг друга понимают, то велика вероятность того, что реализованный вами функционал - правильный.

### Документирование

Чтобы ваш труд не пропал и принёс максимальную пользу обществу, разработчики MoniQue призывают вас снабжать код подробной документацией.

Кроме того, файл `README.md` или соответствующий файл с документацией должен содержать инструкцию с тем, каким образом можно собрать и использовать ваш компонент в качестве библиотеки для алгоритмов и сервисов, которые будут реализовывать какую-либо логику.

После того, как примеры будут разработаны и проверены, их можно задокументировать и развернуть как любой другой компонент.

### Резюмируя

Разработка "компонента-обёртки" требует тщательного и вдумчивого подхода.
После того как он будет разработан, написание различных компонентов с определённой логикой должно быть немногим сложнее чем написание обычных функций, которые есть в любом языке программирования.
