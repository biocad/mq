## Контроллер

Что умеет делать компонент в системе MoniQue?
Принимать и отправлять сообщения.
С помощью этих возможностей можно сконструировать компонент-сервис, который будет принимать сообщение с настройками для выполнения алгоритма, запускать алгоритм и отсылать обратно сообщение с результатом.

> Справка: в предыдущей версии MoniQue такое поведение было единственно возможным, поэтому и компоненты в те славные времена назывались "воркерами" ("рабочими"), что символизировало их поведение.

Очень здорово, если поставленную задачу можно выполнить за несколько миллисекунд.
Тогда для обработки таких сообщений можно запустить всего один компонент, который будет их обрабатывать.
Но что делать, если выполнение алгоритма будет занимать большее количество времени и один компонент уже не будет справляться с обработкой таких сообщений?

Разумным решением будет запустить несколько экземпляров однотипных компонентов, которые являлись бы "кластером" сервисов, умеющих выполнять одну и ту же задачу.
Но сразу же встаёт вопрос: а как распределять задачи между таким кластером?
Ведь если все компоненты-сервисы подключить к "одному месту", то при получении очередного сообщения-задания **все** свободные компоненты будут получать это сообщение и начинать работу.
А это не то поведение, которое мы ожидаем.

На помощь приходит контроллер, который предназначен для решения этой проблемы.
На самом деле, контроллер по жизни - тоже компонент, у которого есть определённая и фиксированная функция.

### Логика работы

Задача контроллера проста: принять определённое сообщение от "одного места" и отдать его одному из компонентов, подключенных к нему.

От "одного места" контроллер забирает только то сообщение, у которого поле `spec` соответствует заданному и поле `type = config`.
Тип `config` используется потому, что контроллер перераспределяет сообщения только с постановкой задачи для выполнения, а все другие типы сообщений посылаются и получаются из очереди стандартными способами.

Для распределения задач между подключёнными компонентами используется подход "Один к одному", который был описан в транспортном слое.

Для того чтобы подключённые компоненты могли забирать задачи, им необходимо знать адрес соответствующего контроллера (его хост и порт).

### Реализация

Если задуматься, то контроллер всегда выполняет одну и ту же функцию.
Разные контроллеры отличаются только полем `spec` обрабатываемых сообщений и портом.
Для того чтобы не запускать отдельного приложения под каждый тип сообщения, используется многопоточность.
Под каждый `spec` с заданным портом производится запуск одного контроллера, который работает в отдельном потоке.

То, какие порты для каких сообщений использовать, данное приложение понимает из файла `config.json`, полe `params -> mq_controller -> connections`:

```
"params":{
  "mq_controller": {
    "connections": {
      "<spec_сообщения>": <порт_контроллера>,
      "<spec_сообщения>": <порт_контроллера>
    } 
  }
}
```

При запуске приложения `mq-controller` из файла `config.json` считывается информация о том, для каких сообщений нужно поднять контроллеры.
После этого в отдельных потоках, отделившихся от основного потока приложения, на соответствующих портах поднимаются контроллеры.
Раз в минуту приложение проверяет `config.json` на предмет того, не добавились ли в поле `connections` новые конфигурации для контроллеров.
Если конфигурации добавились, то соответствующие контроллеры будут развёрнуты. 
Если какие-то конфигурации изменились или были удалены, то приложение **НИКАК НЕ ОБРАБОТАЕТ** эти случаи.
Для их обработки потребуется перезапуск всего приложения с контроллерами.

### Сборка и запуск

Подробности сборки и запуска описаны в соответствующем репозитории [mq-controller](https://github.com/biocad/mq-controller).

### Резюмируя

Контроллер предназначен для распределения задач между однотипными компонентами.
Для того чтобы соответствующий компонент смог получать от своего контроллера задачи, он должен знать `spec` ожидаемых сообщений, хост, на котором развёрнут контроллер, а также определённый порт, который будет предназначен именно для этого типа сообщений.
Всю эту информацию задают и документируют разработчики компонентов.





