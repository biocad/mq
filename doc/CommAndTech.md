## Коммуникационный слой и технический слой

Представьте, вы сидите в кабинете.
У вас на столе два телефона, на одном нарисована буква К, а на другом - буква T.

Телефон К вам нужен для того, чтобы решать действительно важные дела, звонить другим людям, запрашивать информацию или же наоборот, выполнять поручения других.
В общем - через телефон К проходит вся ваша рабочая жизнь.
Жизнь на телефоне К у всех людей разная, все выполняют разные задачи.

Телефон Т нужен немного для другого.
Вам его выдали со следующими инструкциями.
Во-первых, ваше руководство очень заботится о вас и просит раз в какой-то промежуток времени звонить по телефону Т и говорить, что с вами всё в порядке и беспокоиться не о чем.
Во-вторых, вас могут попросить прекратить делать задачу, которой вы сейчас занимаетесь, если она потеряла актуальность.
Жизнь на телефоне Т у всех людей одинаковая и ничем не различается.

Это была аналогия коммуникационного (К) и технического (Т) слоёв.
Каждый компонент с помощью описанного ранее протокола и транспортного слоя может общаться либо в коммуникационном, либо в техническом слое.
Различие между ними следующие:
  1. порты для этих слоёв различные, дабы разделить их на физическом уровне;
  2. технический слой предназначен для служебных сообщений MoniQue, в то время как коммуникационный предназначен для передачи содержательных по смыслу сообщений.
  
На этом различия между ними заканчиваются.
Важно понимать, что про технический слой нужно думать только при разработке компонента на каком-нибудь новом языке программирования.
После разработки такового про технический слой можно забыть и думать в контексте только коммуникационного.

> Технический момент: так как компонент всё-таки должен обрабатывать сообщения из различных (К и Т) слоёв, то это логичным образом приводит нас к тому, что компонент должен быть реализован как многопоточное приложение.

### Коммуникационный слой

Как уже упоминалось, именно в коммуникационном слое вся суть.
Ограничений на данном слое на логику работы нет.

Приведём несколько простых примеров, на основе которых можно строить более сложную логику.

*В дальнейшем этот раздел будет пополняться другими примерами.*

#### А говорит, B слушает

Пусть у нас есть два компонента: `A` и `B`.
Компонент `A` с некоторой периодичностью шлёт сообщения в систему MoniQue, компонент `B` его слушает и печатает.

Код для компонента `A` на языке python может тогда выглядеть следующим образом:

```python
def run(self, sched_out, contr_out, sched_in, message):
    while True:
        message = create_message(b'', self.get_config().creator, 1e17, 'example_simple', 'JSON', 'config', b"{ \"message\" : \"Hello! It's python simple speaker.\" }")
        print(b'sent %s' % message.data)
        sched_in.send(message)
        time.sleep(2)
```

Построчно тут происходит следующее:
  1. определяем функцию, в которой...
  2. в бесконечном цикле...
  3. создаём сообщение с заданными полями (обращаем внимание на поле `spec = example_simple`, `encoding = JSON`, `type = config`)...
  4. печатаем его для лога...
  5. отправляем в Scheduler (одно место)...
  6. делаем передышку в 2 секунды.
  
А код для компонента `B` будем следующим:

```python
def run(self, sched_out, contr_out, sched_in, message):
    while True:
        tag, msg = sched_out.recv_multipart()
        if message_spec(tag) == "example_simple":
            print(msg.data)
            message.value = "Processed message from %s" % msg.creator
```

Построчно:
  1. определяем функцию, в которой...
  2. в бесконечном цикле...
  3. получаем пришедшее из одного места сообщение с тэгом...
  4. проверяем, что поле `spec` из тэга совпадает с `example_simple`...
  5. и если это действительно так, то печатаем полученное сообщение и...
  6. делаем заметку про то, что мы приняли такое-то сообщение.
  
Остальные примеры будут дописываться по мере появления.

### Технический слой

Технический слой предоставляет разработчикам MoniQue как-то единообразно воздействовать на компоненты, подключенные к этой системе.
Компонент на новом языке программирования должен уметь правильно обрабатываеть сообщения, описанные ниже.

> Замечание: далее будет упоминаться конфигурационный файл приложения `config.json`.
> Он будет описан дальше в отдельном разделе.
> А пока что его можно понимать как специальный файл, из которого можно взять различные параметры для приложения.

#### Monitoring

> "Руководство заботится о вас и просит время от времени звонить по телефону Т и говорить, всё ли у вас нормально."

Параметры сообщения:
- `spec = monitoring`;
- `type = data`;
- `encoding = JSON`.

Поле `data` имеет вид:
```
{ sync_time :: timestamp
, name      :: str
, is_alive  :: bool
, message   :: str
}
```
где:
  * `sync_time` - время, когда компонент отправил данное сообщение;
  * `name` - имя компонента, который отправил данное сообщение (берётся из config.json);
  * `is_alive` - жив ли поток приложения компонента, который отвечает за коммуникационный слой;
  * `message` - актуальное сообщение, которое разработчик компонента хотел бы видет при мониторинге системы (пример этого сообщения формируется в "А готорит, B слушает" на последней строчке компонента B).
  
Несложно догадаться, что логика любого компонента должна быть следующая:
 * в заданный промежуток времени (который берётся из config.json) компонент забирает необходимые параметры (имя компонента, состояние "коммуникационного" потока и сообщение от него);
 * засекает текущее время;
 * формирует сообщение с соответствующими полями;
 * отправляет его в центральное место по техническому порту.

Данный тип сообщения предназначен для отслеживания доступности и состояния различных компонентов и сервисов MoniQue.

#### Kill

> "Вас могут попросить прекратить делать задачу, которой вы сейчас занимаетесь, если она потеряла актуальность."

Параметры сообщения:

- `spec = kill`;
- `type = config`;
- `encofing = JSON`.

Поле `data` имеет вид:
```
{ task_id :: hash
}
```
где 
  * `task_id` - идентификатор сообщения, выполнение которого мы хотим прекратить.
  
Название `task_id` может немного ввести в заблуждение.
Дело в том, что под задачей в данном месте понимается то сообщение (скорее всего, с типом `config`), которое несло в себе запрос на выполнение какой-либо задачи.

Для того, чтобы правильно обработать данное сообщение, компонент должен реализовать поведение, состоящее из двух частей.

Первая часть относится к коммуникационному слою:
  * при получении очередного сообщения в данном слое компонент должен обновить ID сообщения в месте, которое будет доступно техническому слою;
  * продолжить выполнение задачи.
  
Вторая часть относится к техническому слою:
  * технический слой при получении сообщения `Kill` сопоставляет присланный идентификатор задачи с тем, который хранится в переменной, которую обновляет коммуникационный слой;
  * если идентификаторы совпадают, коммуникационный слой приложения перезапускается.
  
По поводу логики прерывания задачи может быть много вопросов.
В частности, можно задаться вопросом "А зачем перезапускать весь коммуникационный слой?" или "Может быть достаточно завершить выполнение какой-то отдельной функции?".
На самом деле, поведение не обязано быть именно таким, как описано выше.
Просто разработчики MoniQue на текущий момент в своих компонентах пришли к такому решению.
Главное - чтобы после проведения соответствующих манипуляций высвободились ресурсы, которые были заняты "убиваемой" задачей.
