## Протокол

Протокол системы MoniQue - это формат сообщений и набор правил, который позволяет компонентам общаться друг с другом и понимать друг друга.
Совершенно очевидно, что легче и правильней всего будет взять какой-то существующий формат и, используя его, договориться (или декларировать) о том, какие там будут поля и что они будут значить.

В MoniQue версии 2 таким форматом был [JSON](https://www.json.org/json-en.html).
Это хороший и удобный формат, но он не поддерживает бинарные данные и имеет накладные расходы на служебные символы.
Поэтому в MoniQue версии 3 нами был выбран другой формат, о котором скажем пару слов.

### MessagePack

[MessagePack](https://msgpack.org/) - бинарный формат, который по структуре очень похож на JSON. 
Этакий бинарный JSON.
К примеру, вот такой JSON
```
{"compact":true,"schema":0, "message":"this is message"}
```
в формате MessagePack будет выглядеть следующим образом (как последовательность [HEX](https://en.wikipedia.org/wiki/Hexadecimal) символов):
```
83 a7 63 6f 6d 70 61 63 74 c3 a6 73 63 68 65 6d 61 00 a7 6d 65 73 73 61 67 65 af 74 68 69 73 20 69 73 20 6d 65 73 73 61 67 65
```
или как последовательность символов в [Base64](https://en.wikipedia.org/wiki/Base64):
```
g6djb21wYWN0w6ZzY2hlbWEAp21lc3NhZ2WvdGhpcyBpcyBtZXNzYWdl
```
Подробнее можно узнать на сайте этого формата и в его [спецификации](https://github.com/msgpack/msgpack/blob/master/spec.md).

На самом деле, MessagePack практически всегда можно перевести в JSON и обратно.
Поэтому при дальнейшем описании протокола мы будем пользоваться форматом JSON, при этом подразумевая, что в системе это сообщение будет жить в формате MessagePack.

В MessagePack есть следующие стандартные типы: nil (пустой), bool (булевский), int (целочисленный), float (с плавающей точкой), str (строковый), bin (бинарный), array (массив), map ("объект"), ext (дополнительные расширения).
И поле с типом мы будем обозначать так: `поле :: тип`.

Коль скоро мы договорились об основном формате, настало время договориться о часто используемых обозначениях.

### Обозначения

Помимо стандартных типов, которые описаны в формате MessagePack, мы заведём дополнительные, которые будут выражаться через стандартные, но иметь какой-то определённый смысл.

**timestamp = int** - [Unix-время](https://en.wikipedia.org/wiki/Unix_time) **в миллисекундах**. Данный формат времени настоятельно рекомендуется использовать в разрабатываемых компонентах.

**hash = bin** - hash-сумма от строки по методу [SHA-1](https://en.wikipedia.org/wiki/SHA-1).

### Формат сообщения

Сообщение имеет тип `map` с ключом типа `str`. В сообщении должны присутствовать следующие поля:

```
{ id         :: hash
, pid        :: hash
, creator    :: str
, created_at :: timestamp
, expires_at :: timestamp
, spec       :: str
, encoding   :: str
, type       :: str
, data       :: bin
}
```
А теперь подробнее про каждое поле подробнее.

#### id

Идентификатор сообщения, вычисляется как hash-сумма от строки `"<creator>:<created_at>:<spec>"` и переводится в формат [Base64](https://en.wikipedia.org/wiki/Base64), где `<поле>` заполняется значением из соответствующего поля (читай ниже).
> Пример: если пользователь или сервис с идентификатором `00000000-0000-0000-0000-000000000000` в момент времени `1525427613253` создал сообщение со cпецификацией `example_message`, то идентификатор сообщения после перевода в Base64 будет `bqMjFhN9oWV/PbBCa26Wv7bRufo=`.
Формат Base64 важен, так как в идентификаторе не должно встречаться символа двоеточия. Почему это должно быть так, будет понятно из раздела ["Заголовок сообщения"](#Заголовок-сообщения).

#### pid

Идентификатор сообщения, который является родительским для данного, содержит поле `id` родительского сообщения. 
Если сообщение не имеет "родительского", это поле заполяется пустой строкой.
Родительсткое сообщение определяется с помощью логики.
> Пример: компонент `A` решил что-нибудь спросить у компонента `B`, отправив сообщение `x`.
> Компонент `B`, отправляя в ответ компоненту `A` сообщение `y`, должен в поле `pid` сообщения `y` вставить поле `id` из сообщения `x`.

Это один из возможных примеров (но не единственный) использования поля `pid`.

#### creator

Идентификатор пользователя/сервиса/компонента, который породил данное сообщение.
Для уточнения того, что в текущий момент брать в качестве идентификатора, можно обратиться с создателям MoniQue.
Как только данное поле будет зафиксировано, оно будет отражено в данном месте документации.

#### created_at

Unix-время создания сообщения.

#### expires_at

Unix-время того момента, когда данное сообщение станет неактуальным для системы.
> Пример: пусть компонент `A` запрашивает у компонента `B` какую-либо информацию с помощью сообщения `x`, в котором указано "истекающее" время (к примеру, 1525427613253).
> Если `B` не вернёт ответ раньше 1525427613253, то компоненту `A` ответ будет уже неважен.

Если сообщение не имеет "срока годности" (то есть оно будет актуально всегда), это поле заполняется нулём.

#### spec

Спецификация сообщения в следующем формате: `project_message`, где `project` и `message` могут содержать следующие символы: **маленькие** латинские буквы `a-z`, цифры `0-9`, дефис `-`.
> Пример: в проекте-сервисе `ss` (Semantic System) есть сообщение, которое служит для передачи аннотации и называется `ig-annotate`.
> Тогда поле `spec` для такого сообщения будет `ss_ig-annotate`.

Данное поле очень важно по следующим причинам (некоторые определения будут даны позже):
  * оно определяет то, что будет находиться внутри передаваемых сообщений;
  * для распределения задач между однотипными компонентами может использоваться контроллер, который будет определятся по данному полю;
  * **центральное место (Scheduler) не будет пропускать сообщения в очередь, если поле spec сообщения не зарегистрировано (читай "не задокументировано") в системе**. Данное правило позволяет избежать появления в системе сообщений, на которых нет документации.
  
#### encoding

Кодировка, в которой хранятся данные сообщения.
В целом, кодировка может быть любого формата, который можно преобразовать в бинарную строку.
На текущий момент поддерживаются следующие кодировки: `JSON` и `MessagePack`.
Они записываются именно таким образом, иначе будут нераспознаны в системе.
Если вам нужна ещё какая-нибудь кодировка, обратитесь с этим предложением к разработчикам MoniQue.
Возможно, вам помогут.

#### type

Тип сообщения.
В MoniQue всего 4 типа сообщений: 
  1. `config` - сообщение с какой-либо конфигурацией. Обычно используется для того, чтобы один компонентом поставить какую-либо задачу другому компоненту;
  2. `result` - сообщение с каким-либо результатом. Обычно является ответом на сообщение с типом `config`;
  3. `error` - сообщение с ошибкой. Может быть как ответом на сообщение с типом `config` при неудачном выполнении задачи, а может самостоятельно порождаться каким-либо компонентом. Подробнее про данный тип читай [тут](Error.md);
  4. `data` - сообщение с произвольными данными.
Вполне может оказаться так, что сообщения могут иметь одинаковое поле `spec`, но различное поле `type`.
> Пример: сообщение со `spec = ss_ig-annotate` и `type = config` является запросом на аннотирование.
> А сообщение со `spec = ss_ig-annotate` и `type = result` содержит в себе результат аннотирования.

#### data

Данные, которые содержатся в сообщении.
Несложно заметить, все остальные поля являются служебными и являются некоторым описанием данных.
В то время как именно поле `data` несёт в себе содержательную информацию.
Данные могут быть любыми, но должны быть сформированы по правилам:
  1. содержимое соответствует документации (про документацию читай ниже);
  2. содержимое записано в бинарном виде;
  3. кодировка соответсвует той, которая заявлена в поле `encoding` (если это `MessagePack` - то он и так бинарный; если это `JSON` - то его можно превратить в строку, а затем в ByteString/byte array).

Хотя видимых ограничений на передачу сообщений размера (2^32)-1 байт (4 Gb) нет, разработчики MoniQue настоятельно рекомендуют пересылать данные не более 1 Mb.


### Заголовок сообщения

В системе MoniQue сообщение никогда не путешествует поодиночке, но вместе с заголовком (или тэгом, англ. Tag).
Когда ты, мой уважаемый читатель, отправляешь письмо по электронной почте, то всегда указываешь заголовок (тему) письма, не так ли?
Точно также, когда сообщение отправляется в систему MoniQue, оно должно предваряться заголовком.
Но, милый читатель, тебе не нужно его придумывать самому!

Для каждого сообщения заголовок формируется следующим образом: 
  1. нужно взять поля `type`, `spec`, `id`, `pid` и `creator` из сообщения;
  2. сделать одну строку из этих полей, разделив их двоеточием.
  
Заголовок сообщения готов.
Нужно заметить, что если поле `pid` пусто (у сообщения нет родительского), то в заголовке будут идти два двоеточия подряд, и это нормально.

> Пример: для сообщения с соответствующими полями `config`, `ss_ig-annotate`, `1is0VOdSRZl1rcgRqQbsJRe1KOI`, `` (нет родительского сообщения) и `00000000-0000-0000-0000-000000000000` заголовок
> сообщения будет иметь вид `config:ss_ig-anotate:1is0VOdSRZl1rcgRqQbsJRe1KOI=::00000000-0000-0000-0000-000000000000`.

В месте где было [описано](#id) поле `id`, упонималось, что оно должно быть в [Base64](https://en.wikipedia.org/wiki/Base64).
Необходимость перевода идентификатора сообщения в Base64 обосновывается как раз тем, что среди символом этой таблицы нет символа двоеточия, а значит, в заголовке сообщения не появится случайного разделителя.

Можно задаться вопросом: а для чего вообще нужен заголовок сообщения?
Ответов на этот вопрос несколько.
Во-первых, по заголовку сообщения достаточно удобно понимать, должен ли обрабатывать его компонент или нет, ему ли оно предназначалось или нет.
Во-вторых, никто нам не запрещает через некоторое время повысить защищённость системы и ввести шифрование на сообщение.
Тогда единственным способом, которым можно будет понять про содержимое сообщение, будет только его заголовок, который шифроваться не будет.
Это не единственные, но самые важные моменты, для чего нужен заголовок сообщения.




